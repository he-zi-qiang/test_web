<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ËøõÁ®ãË∞ÉÂ∫¶ÁÆóÊ≥ïÊ®°ÊãüÂô®</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .control-panel {
            background: rgba(255,255,255,0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .input-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            font-weight: bold;
            margin-bottom: 8px;
            color: #555;
        }

        .form-group input, .form-group select {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            color: white;
        }

        .btn-info {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .process-table {
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .process-table h3 {
            margin-bottom: 15px;
            color: #555;
            text-align: center;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }

        th, td {
            padding: 12px;
            text-align: center;
            border: 1px solid #ddd;
        }

        th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        tr:hover {
            background-color: #e3f2fd;
        }

        .visualization {
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .gantt-chart {
            position: relative;
            height: 400px;
            overflow-x: auto;
            overflow-y: hidden;
            border: 2px solid #ddd;
            border-radius: 10px;
            background: #f8f9fa;
        }

        .chart-container {
            position: relative;
            min-width: 800px;
            height: 100%;
        }

        .time-axis {
            position: absolute;
            bottom: 0;
            left: 50px;
            right: 20px;
            height: 30px;
            border-top: 2px solid #333;
        }

        .process-axis {
            position: absolute;
            left: 0;
            top: 20px;
            bottom: 30px;
            width: 50px;
            border-right: 2px solid #333;
        }

        .process-bar {
            position: absolute;
            height: 30px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .process-label {
            position: absolute;
            left: 5px;
            width: 40px;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
            color: #555;
        }

        .time-label {
            position: absolute;
            bottom: 5px;
            font-size: 10px;
            color: #555;
            transform: translateX(-50%);
        }

        .current-time-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ff4757;
            z-index: 100;
            transition: left 0.3s linear;
        }

        .current-time-line::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 10px solid #ff4757;
        }

        .status-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .status-box {
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .status-box h4 {
            margin-bottom: 15px;
            color: #555;
            text-align: center;
            font-size: 18px;
        }

        .ready-queue {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .process-item {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .running-process {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .results {
            background: rgba(255,255,255,0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .results h3 {
            color: #555;
            margin-bottom: 20px;
            text-align: center;
            font-size: 24px;
        }

        .average-time {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
            margin-top: 20px;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
        }

        @media (max-width: 768px) {
            .input-section {
                grid-template-columns: 1fr;
            }
            
            .status-panel {
                grid-template-columns: 1fr;
            }
            
            .buttons {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ ËøõÁ®ãË∞ÉÂ∫¶ÁÆóÊ≥ïÊ®°ÊãüÂô®</h1>
            <p>ÊîØÊåÅÂÖàÊù•ÂÖàÊúçÂä°(FCFS)„ÄÅÊó∂Èó¥ÁâáËΩÆËΩ¨(RR)„ÄÅÊúÄÁü≠Ââ©‰ΩôÊó∂Èó¥‰ºòÂÖà(SRTF)ÁÆóÊ≥ï</p>
        </div>

        <div class="control-panel">
            <div class="input-section">
                <div class="form-group">
                    <label for="processCount">ËøõÁ®ãÊï∞Èáè:</label>
                    <input type="number" id="processCount" value="4" min="1" max="10">
                </div>
                <div class="form-group">
                    <label for="timeQuantum">Êó∂Èó¥ÁâáÂ§ßÂ∞è (‰ªÖRRÁÆóÊ≥ï):</label>
                    <input type="number" id="timeQuantum" value="2" min="1" max="10">
                </div>
            </div>
            
            <div class="buttons">
                <button class="btn btn-primary" onclick="generateRandomProcesses()">üé≤ ÈöèÊú∫ÁîüÊàêËøõÁ®ã</button>
                <button class="btn btn-success" onclick="startScheduling('FCFS')">‚ñ∂Ô∏è FCFSË∞ÉÂ∫¶</button>
                <button class="btn btn-warning" onclick="startScheduling('RR')">‚è∞ RRË∞ÉÂ∫¶</button>
                <button class="btn btn-info" onclick="startScheduling('SRTF')">‚ö° SRTFË∞ÉÂ∫¶</button>
            </div>
        </div>

        <div class="process-table">
            <h3>üìã ËøõÁ®ãÊéßÂà∂Âùó (PCB)</h3>
            <table id="processTable">
                <thead>
                    <tr>
                        <th>ËøõÁ®ãID</th>
                        <th>Âà∞ËææÊó∂Èó¥</th>
                        <th>ÊúçÂä°Êó∂Èó¥</th>
                        <th>Ââ©‰ΩôÊó∂Èó¥</th>
                        <th>Áä∂ÊÄÅ</th>
                    </tr>
                </thead>
                <tbody id="processTableBody">
                </tbody>
            </table>
        </div>

        <div class="status-panel">
            <div class="status-box">
                <h4>üèÉ ÂΩìÂâçËøêË°åËøõÁ®ã</h4>
                <div id="runningProcess" class="running-process">Êó†</div>
            </div>
            <div class="status-box">
                <h4>‚è≥ Â∞±Áª™ÈòüÂàó (*Ready)</h4>
                <div id="readyQueue" class="ready-queue"></div>
            </div>
        </div>

        <div class="visualization">
            <h3>üìä ÁîòÁâπÂõæÂèØËßÜÂåñ (Êó∂Èó¥-ËøõÁ®ãÂùêÊ†áÁ≥ª)</h3>
            <div class="gantt-chart">
                <div class="chart-container" id="chartContainer">
                    <div class="process-axis" id="processAxis"></div>
                    <div class="time-axis" id="timeAxis"></div>
                    <div class="current-time-line" id="currentTimeLine"></div>
                </div>
            </div>
        </div>

        <div class="results">
            <h3>üìà Ë∞ÉÂ∫¶ÁªìÊûú</h3>
            <table id="resultsTable">
                <thead>
                    <tr>
                        <th>ËøõÁ®ãID</th>
                        <th>Âà∞ËææÊó∂Èó¥</th>
                        <th>ÊúçÂä°Êó∂Èó¥</th>
                        <th>ÂÆåÊàêÊó∂Èó¥</th>
                        <th>Âë®ËΩ¨Êó∂Èó¥</th>
                        <th>Â∏¶ÊùÉÂë®ËΩ¨Êó∂Èó¥</th>
                    </tr>
                </thead>
                <tbody id="resultsTableBody">
                </tbody>
            </table>
            <div id="averageTime" class="average-time"></div>
        </div>
    </div>

    <script>
        // ËøõÁ®ãÊéßÂà∂ÂùóPCBÁªìÊûÑ
        class PCB {
            constructor(id, arrivalTime, serviceTime) {
                this.id = id;
                this.arrivalTime = arrivalTime;
                this.serviceTime = serviceTime;
                this.remainingTime = serviceTime;
                this.status = 'waiting';
                this.completionTime = 0;
                this.turnaroundTime = 0;
                this.weightedTurnaroundTime = 0;
            }
        }

        // ÂÖ®Â±ÄÂèòÈáè
        let processes = [];
        let isAnimating = false;
        let animationSpeed = 1000;
        let currentTime = 0;

        // ËøõÁ®ãÈ¢úËâ≤Êï∞ÁªÑ
        const processColors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', 
            '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F',
            '#BB8FCE', '#85C1E9'
        ];

        // ÂàùÂßãÂåñ
        document.addEventListener('DOMContentLoaded', function() {
            generateRandomProcesses();
        });

        // ÁîüÊàêÈöèÊú∫ËøõÁ®ã
        function generateRandomProcesses() {
            const count = parseInt(document.getElementById('processCount').value);
            processes = [];
            
            for (let i = 0; i < count; i++) {
                const arrivalTime = Math.floor(Math.random() * 5);
                const serviceTime = Math.floor(Math.random() * 8) + 1;
                processes.push(new PCB(`P${i + 1}`, arrivalTime, serviceTime));
            }
            
            updateProcessTable();
            clearResults();
        }

        // Êõ¥Êñ∞ËøõÁ®ãË°®
        function updateProcessTable() {
            const tbody = document.getElementById('processTableBody');
            tbody.innerHTML = '';
            
            processes.forEach(process => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${process.id}</td>
                    <td>${process.arrivalTime}</td>
                    <td>${process.serviceTime}</td>
                    <td>${process.remainingTime}</td>
                    <td><span style="color: ${getStatusColor(process.status)}">${getStatusText(process.status)}</span></td>
                `;
            });
        }

        // Ëé∑ÂèñÁä∂ÊÄÅÈ¢úËâ≤
        function getStatusColor(status) {
            switch(status) {
                case 'running': return '#28a745';
                case 'ready': return '#007bff';
                case 'waiting': return '#6c757d';
                case 'completed': return '#dc3545';
                default: return '#6c757d';
            }
        }

        // Ëé∑ÂèñÁä∂ÊÄÅÊñáÊú¨
        function getStatusText(status) {
            switch(status) {
                case 'running': return 'ËøêË°å‰∏≠';
                case 'ready': return 'Â∞±Áª™';
                case 'waiting': return 'Á≠âÂæÖ';
                case 'completed': return 'Â∑≤ÂÆåÊàê';
                default: return 'Êú™Áü•';
            }
        }

        // ÂºÄÂßãË∞ÉÂ∫¶
        async function startScheduling(algorithm) {
            if (isAnimating) return;
            
            // ÈáçÁΩÆËøõÁ®ãÁä∂ÊÄÅ
            processes.forEach(p => {
                p.remainingTime = p.serviceTime;
                p.status = 'waiting';
                p.completionTime = 0;
                p.turnaroundTime = 0;
                p.weightedTurnaroundTime = 0;
            });

            clearResults();
            initializeGanttChart();
            
            isAnimating = true;
            currentTime = 0;

            switch(algorithm) {
                case 'FCFS':
                    await fcfsScheduling();
                    break;
                case 'RR':
                    await rrScheduling();
                    break;
                case 'SRTF':
                    await srtfScheduling();
                    break;
            }

            isAnimating = false;
            calculateResults();
            displayResults();
        }

        // ÂÖàÊù•ÂÖàÊúçÂä°Ë∞ÉÂ∫¶ÁÆóÊ≥ï
        async function fcfsScheduling() {
            const sortedProcesses = [...processes].sort((a, b) => a.arrivalTime - b.arrivalTime);
            
            for (const process of sortedProcesses) {
                // Á≠âÂæÖËøõÁ®ãÂà∞Ëææ
                while (currentTime < process.arrivalTime) {
                    await sleep(animationSpeed);
                    currentTime++;
                    updateTimeLine();
                }

                // ËøêË°åËøõÁ®ã
                process.status = 'running';
                updateStatus(process, []);
                updateProcessTable();

                for (let i = 0; i < process.serviceTime; i++) {
                    addGanttBar(process, currentTime, 1);
                    await sleep(animationSpeed);
                    currentTime++;
                    updateTimeLine();
                }

                process.status = 'completed';
                process.completionTime = currentTime;
                updateProcessTable();
            }
        }

        // Êó∂Èó¥ÁâáËΩÆËΩ¨Ë∞ÉÂ∫¶ÁÆóÊ≥ï
        async function rrScheduling() {
            const timeQuantum = parseInt(document.getElementById('timeQuantum').value);
            const readyQueue = [];
            let processIndex = 0;

            while (processIndex < processes.length || readyQueue.length > 0) {
                // Ê£ÄÊü•Êñ∞Âà∞ËææÁöÑËøõÁ®ã
                while (processIndex < processes.length && processes[processIndex].arrivalTime <= currentTime) {
                    processes[processIndex].status = 'ready';
                    readyQueue.push(processes[processIndex]);
                    processIndex++;
                }

                if (readyQueue.length === 0) {
                    await sleep(animationSpeed);
                    currentTime++;
                    updateTimeLine();
                    continue;
                }

                const currentProcess = readyQueue.shift();
                currentProcess.status = 'running';
                
                const otherReady = readyQueue.map(p => p.id);
                updateStatus(currentProcess, otherReady);
                updateProcessTable();

                const executeTime = Math.min(timeQuantum, currentProcess.remainingTime);
                
                for (let i = 0; i < executeTime; i++) {
                    addGanttBar(currentProcess, currentTime, 1);
                    await sleep(animationSpeed);
                    currentTime++;
                    currentProcess.remainingTime--;
                    updateTimeLine();
                    updateProcessTable();
                }

                if (currentProcess.remainingTime > 0) {
                    currentProcess.status = 'ready';
                    readyQueue.push(currentProcess);
                } else {
                    currentProcess.status = 'completed';
                    currentProcess.completionTime = currentTime;
                }

                updateProcessTable();
            }
        }

        // ÊúÄÁü≠Ââ©‰ΩôÊó∂Èó¥‰ºòÂÖàË∞ÉÂ∫¶ÁÆóÊ≥ï
        async function srtfScheduling() {
            let completedCount = 0;
            
            while (completedCount < processes.length) {
                // Ëé∑ÂèñÂ∑≤Âà∞Ëææ‰∏îÊú™ÂÆåÊàêÁöÑËøõÁ®ã
                const availableProcesses = processes.filter(p => 
                    p.arrivalTime <= currentTime && p.remainingTime > 0
                );

                if (availableProcesses.length === 0) {
                    await sleep(animationSpeed);
                    currentTime++;
                    updateTimeLine();
                    continue;
                }

                // ÈÄâÊã©Ââ©‰ΩôÊó∂Èó¥ÊúÄÁü≠ÁöÑËøõÁ®ã
                const currentProcess = availableProcesses.reduce((min, p) => 
                    p.remainingTime < min.remainingTime ? p : min
                );

                // Êõ¥Êñ∞Áä∂ÊÄÅ
                processes.forEach(p => {
                    if (p.arrivalTime <= currentTime && p.remainingTime > 0) {
                        p.status = p === currentProcess ? 'running' : 'ready';
                    }
                });

                const readyProcesses = processes
                    .filter(p => p.arrivalTime <= currentTime && p.remainingTime > 0 && p !== currentProcess)
                    .map(p => p.id);

                updateStatus(currentProcess, readyProcesses);
                updateProcessTable();

                // ÊâßË°å‰∏Ä‰∏™Êó∂Èó¥Âçï‰Ωç
                addGanttBar(currentProcess, currentTime, 1);
                await sleep(animationSpeed);
                currentTime++;
                currentProcess.remainingTime--;
                updateTimeLine();

                if (currentProcess.remainingTime === 0) {
                    currentProcess.status = 'completed';
                    currentProcess.completionTime = currentTime;
                    completedCount++;
                }

                updateProcessTable();
            }
        }

        // Êõ¥Êñ∞Áä∂ÊÄÅÊòæÁ§∫
        function updateStatus(runningProcess, readyQueue) {
            document.getElementById('runningProcess').textContent = runningProcess ? runningProcess.id : 'Êó†';
            
            const readyQueueDiv = document.getElementById('readyQueue');
            readyQueueDiv.innerHTML = '';
            
            if (readyQueue.length === 0) {
                readyQueueDiv.innerHTML = '<div style="color: #999;">Á©∫</div>';
            } else {
                readyQueue.forEach(processId => {
                    const item = document.createElement('div');
                    item.className = 'process-item';
                    item.textContent = processId;
                    readyQueueDiv.appendChild(item);
                });
            }
        }

        // ÂàùÂßãÂåñÁîòÁâπÂõæ
        function initializeGanttChart() {
            const chartContainer = document.getElementById('chartContainer');
            const processAxis = document.getElementById('processAxis');
            const timeAxis = document.getElementById('timeAxis');
            
            // Ê∏ÖÈô§Áé∞ÊúâÂÜÖÂÆπ
            chartContainer.querySelectorAll('.process-bar').forEach(bar => bar.remove());
            processAxis.innerHTML = '';
            timeAxis.innerHTML = '';

            // Ê∑ªÂä†ËøõÁ®ãÊ†áÁ≠æ
            processes.forEach((process, index) => {
                const label = document.createElement('div');
                label.className = 'process-label';
                label.textContent = process.id;
                label.style.top = `${20 + index * 40 + 15}px`;
                processAxis.appendChild(label);
            });

            // Ê∑ªÂä†Êó∂Èó¥Ê†áÁ≠æ
            const maxTime = Math.max(...processes.map(p => p.arrivalTime + p.serviceTime)) + 10;
            for (let i = 0; i <= maxTime; i++) {
                if (i % 2 === 0) {
                    const label = document.createElement('div');
                    label.className = 'time-label';
                    label.textContent = i;
                    label.style.left = `${i * 30}px`;
                    timeAxis.appendChild(label);
                }
            }
        }

        // Ê∑ªÂä†ÁîòÁâπÂõæÊù°
        function addGanttBar(process, time, duration) {
            const chartContainer = document.getElementById('chartContainer');
            const processIndex = processes.indexOf(process);
            
            const bar = document.createElement('div');
            bar.className = 'process-bar';
            bar.textContent = process.id;
            bar.style.left = `${50 + time * 30}px`;
            bar.style.top = `${20 + processIndex * 40}px`;
            bar.style.width = `${duration * 30}px`;
            bar.style.background = processColors[processIndex % processColors.length];
            
            chartContainer.appendChild(bar);
        }

        // Êõ¥Êñ∞Êó∂Èó¥Á∫ø
        function updateTimeLine() {
            const timeLine = document.getElementById('currentTimeLine');
            timeLine.style.left = `${50 + currentTime * 30}px`;
        }

        // ËÆ°ÁÆóÁªìÊûú
        function calculateResults() {
            processes.forEach(process => {
                process.turnaroundTime = process.completionTime - process.arrivalTime;
                process.weightedTurnaroundTime = process.turnaroundTime / process.serviceTime;
            });
        }

        // ÊòæÁ§∫ÁªìÊûú
        function displayResults() {
            const tbody = document.getElementById('resultsTableBody');
            tbody.innerHTML = '';
            
            let totalTurnaroundTime = 0;
            let totalWeightedTurnaroundTime = 0;
            
            processes.forEach(process => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${process.id}</td>
                    <td>${process.arrivalTime}</td>
                    <td>${process.serviceTime}</td>
                    <td>${process.completionTime}</td>
                    <td>${process.turnaroundTime}</td>
                    <td>${process.weightedTurnaroundTime.toFixed(2)}</td>
                `;
                
                totalTurnaroundTime += process.turnaroundTime;
                totalWeightedTurnaroundTime += process.weightedTurnaroundTime;
            });
            
            const averageTurnaroundTime = totalTurnaroundTime / processes.length;
            const averageWeightedTurnaroundTime = totalWeightedTurnaroundTime / processes.length;
            
            document.getElementById('averageTime').innerHTML = `
                <div>Âπ≥ÂùáÂë®ËΩ¨Êó∂Èó¥: ${averageTurnaroundTime.toFixed(2)}</div>
                <div>Âπ≥ÂùáÂ∏¶ÊùÉÂë®ËΩ¨Êó∂Èó¥: ${averageWeightedTurnaroundTime.toFixed(2)}</div>
            `;
        }

        // Ê∏ÖÈô§ÁªìÊûú
        function clearResults() {
            document.getElementById('resultsTableBody').innerHTML = '';
            document.getElementById('averageTime').innerHTML = '';
            document.getElementById('runningProcess').textContent = 'Êó†';
            document.getElementById('readyQueue').innerHTML = '<div style="color: #999;">Á©∫</div>';
        }

        // Áù°Áú†ÂáΩÊï∞
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>